{
  "java": "import java.util.NoSuchElementException;\n\npublic class Queue<T> {\n    // Node class to represent each element in the queue\n    private static class Node<T> {\n        private T data;\n        private Node<T> next;\n\n        // Constructor for Node\n        public Node(T data) {\n            this.data = data;\n        }\n    }\n\n    private Node<T> first; // Points to the front of the queue\n    private Node<T> last;  // Points to the end of the queue\n    private int size;      // Keeps track of the size of the queue\n\n    // Constructor for Queue\n    public Queue() {\n        first = null;\n        last = null;\n        size = 0;\n    }\n\n    // Check if the queue is empty\n    public boolean isEmpty() {\n        return first == null;\n    }\n\n    // Return the size of the queue\n    public int size() {\n        return size;\n    }\n\n    // Add an element to the end of the queue\n    public void enqueue(T item) {\n        Node<T> newNode = new Node<>(item);\n        if (last != null) {\n            last.next = newNode; // Link the old last node to the new node\n        }\n        last = newNode; // Point last to the new node\n        if (first == null) {\n            first = last; // If the queue was empty, first and last point to the same node\n        }\n        size++;\n    }\n\n    // Remove and return the element from the front of the queue\n    public T dequeue() {\n        if (isEmpty()) {\n            throw new NoSuchElementException(\"Queue is empty\");\n        }\n        T data = first.data; // Get the data from the front node\n        first = first.next;  // Move the front pointer to the next node\n        if (first == null) {\n            last = null; // If the queue becomes empty, last should also be null\n        }\n        size--;\n        return data;\n    }\n\n    // Peek at the front element without removing it\n    public T peek() {\n        if (isEmpty()) {\n            throw new NoSuchElementException(\"Queue is empty\");\n        }\n        return first.data;\n    }\n\n    // Print the elements of the queue\n    public void printQueue() {\n        Node<T> current = first;\n        while (current != null) {\n            System.out.print(current.data + \" \");\n            current = current.next;\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        Queue<Integer> queue = new Queue<>();\n\n        // Add elements to the queue\n        queue.enqueue(1);\n        queue.enqueue(2);\n        queue.enqueue(3);\n\n        // Print the queue\n        System.out.print(\"Queue: \");\n        queue.printQueue();\n\n        // Remove elements from the queue\n        System.out.println(\"Dequeued: \" + queue.dequeue());\n        System.out.println(\"Dequeued: \" + queue.dequeue());\n\n        // Print the queue after dequeue operations\n        System.out.print(\"Queue after dequeuing: \");\n        queue.printQueue();\n\n        // Peek at the front element\n        System.out.println(\"Peek: \" + queue.peek());\n\n        // Print the final state of the queue\n        System.out.print(\"Final Queue: \");\n        queue.printQueue();\n    }\n}\n",
  "cpp": "#include <iostream>\n#include <stdexcept>\n\n// Node class to represent each element in the queue\ntemplate <typename T>\nclass Node {\npublic:\n    T data;\n    Node* next;\n\n    // Constructor for Node\n    Node(T data) {\n        this->data = data;\n        this->next = nullptr;\n    }\n};\n\n// Queue class\ntemplate <typename T>\nclass Queue {\nprivate:\n    Node<T>* front;  // Points to the front of the queue\n    Node<T>* rear;   // Points to the end of the queue\n    int size;        // Keeps track of the size of the queue\n\npublic:\n    // Constructor for Queue\n    Queue() {\n        front = nullptr;\n        rear = nullptr;\n        size = 0;\n    }\n\n    // Check if the queue is empty\n    bool isEmpty() {\n        return front == nullptr;\n    }\n\n    // Return the size of the queue\n    int getSize() {\n        return size;\n    }\n\n    // Add an element to the end of the queue\n    void enqueue(T item) {\n        Node<T>* newNode = new Node<T>(item);\n        if (rear != nullptr) {\n            rear->next = newNode;  // Link the old rear node to the new node\n        }\n        rear = newNode;  // Point rear to the new node\n        if (front == nullptr) {\n            front = rear;  // If the queue was empty, front and rear point to the same node\n        }\n        size++;\n    }\n\n    // Remove and return the element from the front of the queue\n    T dequeue() {\n        if (isEmpty()) {\n            throw std::out_of_range(\"Queue is empty\");\n        }\n        T data = front->data;  // Get the data from the front node\n        Node<T>* temp = front; // Temporarily store the front node\n        front = front->next;   // Move the front pointer to the next node\n        if (front == nullptr) {\n            rear = nullptr; // If the queue becomes empty, rear should also be nullptr\n        }\n        delete temp; // Delete the old front node\n        size--;\n        return data;\n    }\n\n    // Peek at the front element without removing it\n    T peek() {\n        if (isEmpty()) {\n            throw std::out_of_range(\"Queue is empty\");\n        }\n        return front->data;\n    }\n\n    // Print the elements of the queue\n    void printQueue() {\n        Node<T>* current = front;\n        while (current != nullptr) {\n            std::cout << current->data << \" \";\n            current = current->next;\n        }\n        std::cout << std::endl;\n    }\n\n    // Destructor for Queue to free allocated memory\n    ~Queue() {\n        while (!isEmpty()) {\n            dequeue();\n        }\n    }\n};\n\nint main() {\n    Queue<int> queue;\n\n    // Add elements to the queue\n    queue.enqueue(1);\n    queue.enqueue(2);\n    queue.enqueue(3);\n\n    // Print the queue\n    std::cout << \"Queue: \";\n    queue.printQueue();\n\n    // Remove elements from the queue\n    std::cout << \"Dequeued: \" << queue.dequeue() << std::endl;\n    std::cout << \"Dequeued: \" << queue.dequeue() << std::endl;\n\n    // Print the queue after dequeue operations\n    std::cout << \"Queue after dequeuing: \";\n    queue.printQueue();\n\n    // Peek at the front element\n    std::cout << \"Peek: \" << queue.peek() << std::endl;\n\n    // Print the final state of the queue\n    std::cout << \"Final Queue: \";\n    queue.printQueue();\n\n    return 0;\n}\n",
  "javascript": "class Node {\n  constructor(data) {\n    this.data = data;\n    this.next = null;\n  }\n}\n\nclass Queue {\n  constructor() {\n    this.front = null; // Points to the front of the queue\n    this.rear = null;  // Points to the end of the queue\n    this.size = 0;     // Keeps track of the size of the queue\n  }\n\n  // Check if the queue is empty\n  isEmpty() {\n    return this.front === null;\n  }\n\n  // Return the size of the queue\n  getSize() {\n    return this.size;\n  }\n\n  // Add an element to the end of the queue\n  enqueue(item) {\n    const newNode = new Node(item);\n    if (this.rear !== null) {\n      this.rear.next = newNode; // Link the old rear node to the new node\n    }\n    this.rear = newNode; // Point rear to the new node\n    if (this.front === null) {\n      this.front = this.rear; // If the queue was empty, front and rear point to the same node\n    }\n    this.size++;\n  }\n\n  // Remove and return the element from the front of the queue\n  dequeue() {\n    if (this.isEmpty()) {\n      throw new Error(\"Queue is empty\");\n    }\n    const data = this.front.data; // Get the data from the front node\n    this.front = this.front.next; // Move the front pointer to the next node\n    if (this.front === null) {\n      this.rear = null; // If the queue becomes empty, rear should also be null\n    }\n    this.size--;\n    return data;\n  }\n\n  // Peek at the front element without removing it\n  peek() {\n    if (this.isEmpty()) {\n      throw new Error(\"Queue is empty\");\n    }\n    return this.front.data;\n  }\n\n  // Print the elements of the queue\n  printQueue() {\n    let current = this.front;\n    const elements = [];\n    while (current !== null) {\n      elements.push(current.data);\n      current = current.next;\n    }\n    console.log(elements.join(\" \"));\n  }\n}\n\n// Example usage\nconst queue = new Queue();\n\n// Add elements to the queue\nqueue.enqueue(1);\nqueue.enqueue(2);\nqueue.enqueue(3);\n\n// Print the queue\nconsole.log(\"Queue: \");\nqueue.printQueue();\n\n// Remove elements from the queue\nconsole.log(\"Dequeued: \" + queue.dequeue());\nconsole.log(\"Dequeued: \" + queue.dequeue());\n\n// Print the queue after dequeue operations\nconsole.log(\"Queue after dequeuing: \");\nqueue.printQueue();\n\n// Peek at the front element\nconsole.log(\"Peek: \" + queue.peek());\n\n// Print the final state of the queue\nconsole.log(\"Final Queue: \");\nqueue.printQueue();\n"
}
