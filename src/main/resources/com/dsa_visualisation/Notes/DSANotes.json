{
  "DataStructures" : {
    "array": {
      "part1": ["Introduction to Queues", "A queue is a linear data structure that follows the First-In-First-Out (FIFO) principle. This means that the first element added to the queue will be the first one to be removed. Queues are analogous to real-life queues, like waiting in line at a supermarket or a ticket counter.\n\nCharacteristics:\nFIFO Order: The element added first will be removed first.\nTwo Ends: Queues have two ends. The rear (or tail) is where elements are added, and the front (or head) is where elements are removed.\nDynamic Size: Queues can grow and shrink as needed, depending on the implementation.\nTypes of Queues:\nSimple Queue: Basic FIFO queue.\nCircular Queue: The last position is connected back to the first position to make a circle. This helps in efficiently using the available space.\nPriority Queue: Elements are added with priority, and removal is based on priority rather than the order of insertion.\nDeque (Double-Ended Queue): Elements can be added or removed from both the front and rear ends."],

      "part2": ["Operations on Queues", "The fundamental operations performed on a queue include:\n\n1. Enqueue:\nAdding an element to the end (rear) of the queue.\nIf the queue is full (in the case of a fixed-size implementation), an overflow condition occurs.\n2. Dequeue:\nRemoving an element from the front (head) of the queue.\nIf the queue is empty, an underflow condition occurs.\n3. Front:\nAccessing the front element of the queue without removing it.\nUseful for peek operations.\n4. Rear:\nAccessing the last element of the queue.\nUseful for peek operations.\n5. isEmpty:\nChecking whether the queue is empty.\n6. isFull:\nChecking whether the queue is full (primarily in fixed-size implementations)."],

      "part3": ["Applications of Queues\nQueues are used in various scenarios in computer science and real-world applications. Some notable applications include:\n\n1. Operating Systems:\nProcess Scheduling: Queues manage processes in multitasking operating systems. Ready queues and waiting queues are used for scheduling tasks.\nDisk Scheduling: Managing read/write requests to a disk drive.\n2. Networking:\nBuffering: Queues buffer incoming and outgoing data packets.\nRouting: Queues are used in routers and switches to manage data packets.\n3. Simulation:\nEvent Handling: Queues handle events in simulation systems, ensuring events are processed in the order they arrive.\n4. Print Spooling:\nPrint Queues: Managing print jobs sent to a printer.\n5. Breadth-First Search (BFS):\nIn graph algorithms, BFS uses a queue to explore nodes level by level.\n6. CPU Scheduling:\nQueues manage the order of tasks to be executed by the CPU.\n7. Call Center Systems:\nManaging incoming calls in customer service operations."]
    },

    "queue": {
      "part1": ["Introduction to Queues", "A queue is a linear data structure that follows the First-In-First-Out (FIFO) principle. This means that the first element added to the queue will be the first one to be removed. Queues are analogous to real-life queues, like waiting in line at a supermarket or a ticket counter.\n\nCharacteristics:\nFIFO Order: The element added first will be removed first.\nTwo Ends: Queues have two ends. The rear (or tail) is where elements are added, and the front (or head) is where elements are removed.\nDynamic Size: Queues can grow and shrink as needed, depending on the implementation.\nTypes of Queues:\nSimple Queue: Basic FIFO queue.\nCircular Queue: The last position is connected back to the first position to make a circle. This helps in efficiently using the available space.\nPriority Queue: Elements are added with priority, and removal is based on priority rather than the order of insertion.\nDeque (Double-Ended Queue): Elements can be added or removed from both the front and rear ends."],

      "part2": ["Operations on Queues", "The fundamental operations performed on a queue include:\n\n1. Enqueue:\nAdding an element to the end (rear) of the queue.\nIf the queue is full (in the case of a fixed-size implementation), an overflow condition occurs.\n2. Dequeue:\nRemoving an element from the front (head) of the queue.\nIf the queue is empty, an underflow condition occurs.\n3. Front:\nAccessing the front element of the queue without removing it.\nUseful for peek operations.\n4. Rear:\nAccessing the last element of the queue.\nUseful for peek operations.\n5. isEmpty:\nChecking whether the queue is empty.\n6. isFull:\nChecking whether the queue is full (primarily in fixed-size implementations)."],

      "part3": ["Applications of Queues\nQueues are used in various scenarios in computer science and real-world applications. Some notable applications include:\n\n1. Operating Systems:\nProcess Scheduling: Queues manage processes in multitasking operating systems. Ready queues and waiting queues are used for scheduling tasks.\nDisk Scheduling: Managing read/write requests to a disk drive.\n2. Networking:\nBuffering: Queues buffer incoming and outgoing data packets.\nRouting: Queues are used in routers and switches to manage data packets.\n3. Simulation:\nEvent Handling: Queues handle events in simulation systems, ensuring events are processed in the order they arrive.\n4. Print Spooling:\nPrint Queues: Managing print jobs sent to a printer.\n5. Breadth-First Search (BFS):\nIn graph algorithms, BFS uses a queue to explore nodes level by level.\n6. CPU Scheduling:\nQueues manage the order of tasks to be executed by the CPU.\n7. Call Center Systems:\nManaging incoming calls in customer service operations."]
    },

    "stack": {
      "part1": ["Introduction to Queues", "A queue is a linear data structure that follows the First-In-First-Out (FIFO) principle. This means that the first element added to the queue will be the first one to be removed. Queues are analogous to real-life queues, like waiting in line at a supermarket or a ticket counter.\n\nCharacteristics:\nFIFO Order: The element added first will be removed first.\nTwo Ends: Queues have two ends. The rear (or tail) is where elements are added, and the front (or head) is where elements are removed.\nDynamic Size: Queues can grow and shrink as needed, depending on the implementation.\nTypes of Queues:\nSimple Queue: Basic FIFO queue.\nCircular Queue: The last position is connected back to the first position to make a circle. This helps in efficiently using the available space.\nPriority Queue: Elements are added with priority, and removal is based on priority rather than the order of insertion.\nDeque (Double-Ended Queue): Elements can be added or removed from both the front and rear ends."],

      "part2": ["Operations on Queues", "The fundamental operations performed on a queue include:\n\n1. Enqueue:\nAdding an element to the end (rear) of the queue.\nIf the queue is full (in the case of a fixed-size implementation), an overflow condition occurs.\n2. Dequeue:\nRemoving an element from the front (head) of the queue.\nIf the queue is empty, an underflow condition occurs.\n3. Front:\nAccessing the front element of the queue without removing it.\nUseful for peek operations.\n4. Rear:\nAccessing the last element of the queue.\nUseful for peek operations.\n5. isEmpty:\nChecking whether the queue is empty.\n6. isFull:\nChecking whether the queue is full (primarily in fixed-size implementations)."],

      "part3": ["Applications of Queues\nQueues are used in various scenarios in computer science and real-world applications. Some notable applications include:\n\n1. Operating Systems:\nProcess Scheduling: Queues manage processes in multitasking operating systems. Ready queues and waiting queues are used for scheduling tasks.\nDisk Scheduling: Managing read/write requests to a disk drive.\n2. Networking:\nBuffering: Queues buffer incoming and outgoing data packets.\nRouting: Queues are used in routers and switches to manage data packets.\n3. Simulation:\nEvent Handling: Queues handle events in simulation systems, ensuring events are processed in the order they arrive.\n4. Print Spooling:\nPrint Queues: Managing print jobs sent to a printer.\n5. Breadth-First Search (BFS):\nIn graph algorithms, BFS uses a queue to explore nodes level by level.\n6. CPU Scheduling:\nQueues manage the order of tasks to be executed by the CPU.\n7. Call Center Systems:\nManaging incoming calls in customer service operations."]
    },

    "linkedlist": {
      "part1": ["Introduction to Queues", "A queue is a linear data structure that follows the First-In-First-Out (FIFO) principle. This means that the first element added to the queue will be the first one to be removed. Queues are analogous to real-life queues, like waiting in line at a supermarket or a ticket counter.\n\nCharacteristics:\nFIFO Order: The element added first will be removed first.\nTwo Ends: Queues have two ends. The rear (or tail) is where elements are added, and the front (or head) is where elements are removed.\nDynamic Size: Queues can grow and shrink as needed, depending on the implementation.\nTypes of Queues:\nSimple Queue: Basic FIFO queue.\nCircular Queue: The last position is connected back to the first position to make a circle. This helps in efficiently using the available space.\nPriority Queue: Elements are added with priority, and removal is based on priority rather than the order of insertion.\nDeque (Double-Ended Queue): Elements can be added or removed from both the front and rear ends."],

      "part2": ["Operations on Queues", "The fundamental operations performed on a queue include:\n\n1. Enqueue:\nAdding an element to the end (rear) of the queue.\nIf the queue is full (in the case of a fixed-size implementation), an overflow condition occurs.\n2. Dequeue:\nRemoving an element from the front (head) of the queue.\nIf the queue is empty, an underflow condition occurs.\n3. Front:\nAccessing the front element of the queue without removing it.\nUseful for peek operations.\n4. Rear:\nAccessing the last element of the queue.\nUseful for peek operations.\n5. isEmpty:\nChecking whether the queue is empty.\n6. isFull:\nChecking whether the queue is full (primarily in fixed-size implementations)."],

      "part3": ["Applications of Queues\nQueues are used in various scenarios in computer science and real-world applications. Some notable applications include:\n\n1. Operating Systems:\nProcess Scheduling: Queues manage processes in multitasking operating systems. Ready queues and waiting queues are used for scheduling tasks.\nDisk Scheduling: Managing read/write requests to a disk drive.\n2. Networking:\nBuffering: Queues buffer incoming and outgoing data packets.\nRouting: Queues are used in routers and switches to manage data packets.\n3. Simulation:\nEvent Handling: Queues handle events in simulation systems, ensuring events are processed in the order they arrive.\n4. Print Spooling:\nPrint Queues: Managing print jobs sent to a printer.\n5. Breadth-First Search (BFS):\nIn graph algorithms, BFS uses a queue to explore nodes level by level.\n6. CPU Scheduling:\nQueues manage the order of tasks to be executed by the CPU.\n7. Call Center Systems:\nManaging incoming calls in customer service operations."]
    }
  },

  "Algorithms": {
    "binarysearch": {
      "part1": ["Introduction to Queues", "A queue is a linear data structure that follows the First-In-First-Out (FIFO) principle. This means that the first element added to the queue will be the first one to be removed. Queues are analogous to real-life queues, like waiting in line at a supermarket or a ticket counter.\n\nCharacteristics:\nFIFO Order: The element added first will be removed first.\nTwo Ends: Queues have two ends. The rear (or tail) is where elements are added, and the front (or head) is where elements are removed.\nDynamic Size: Queues can grow and shrink as needed, depending on the implementation.\nTypes of Queues:\nSimple Queue: Basic FIFO queue.\nCircular Queue: The last position is connected back to the first position to make a circle. This helps in efficiently using the available space.\nPriority Queue: Elements are added with priority, and removal is based on priority rather than the order of insertion.\nDeque (Double-Ended Queue): Elements can be added or removed from both the front and rear ends."],

      "part2": ["Operations on Queues", "The fundamental operations performed on a queue include:\n\n1. Enqueue:\nAdding an element to the end (rear) of the queue.\nIf the queue is full (in the case of a fixed-size implementation), an overflow condition occurs.\n2. Dequeue:\nRemoving an element from the front (head) of the queue.\nIf the queue is empty, an underflow condition occurs.\n3. Front:\nAccessing the front element of the queue without removing it.\nUseful for peek operations.\n4. Rear:\nAccessing the last element of the queue.\nUseful for peek operations.\n5. isEmpty:\nChecking whether the queue is empty.\n6. isFull:\nChecking whether the queue is full (primarily in fixed-size implementations)."],

      "part3": ["Applications of Queues\nQueues are used in various scenarios in computer science and real-world applications. Some notable applications include:\n\n1. Operating Systems:\nProcess Scheduling: Queues manage processes in multitasking operating systems. Ready queues and waiting queues are used for scheduling tasks.\nDisk Scheduling: Managing read/write requests to a disk drive.\n2. Networking:\nBuffering: Queues buffer incoming and outgoing data packets.\nRouting: Queues are used in routers and switches to manage data packets.\n3. Simulation:\nEvent Handling: Queues handle events in simulation systems, ensuring events are processed in the order they arrive.\n4. Print Spooling:\nPrint Queues: Managing print jobs sent to a printer.\n5. Breadth-First Search (BFS):\nIn graph algorithms, BFS uses a queue to explore nodes level by level.\n6. CPU Scheduling:\nQueues manage the order of tasks to be executed by the CPU.\n7. Call Center Systems:\nManaging incoming calls in customer service operations."]
    },

    "linearsearch": {
      "part1": ["Introduction to Queues", "A queue is a linear data structure that follows the First-In-First-Out (FIFO) principle. This means that the first element added to the queue will be the first one to be removed. Queues are analogous to real-life queues, like waiting in line at a supermarket or a ticket counter.\n\nCharacteristics:\nFIFO Order: The element added first will be removed first.\nTwo Ends: Queues have two ends. The rear (or tail) is where elements are added, and the front (or head) is where elements are removed.\nDynamic Size: Queues can grow and shrink as needed, depending on the implementation.\nTypes of Queues:\nSimple Queue: Basic FIFO queue.\nCircular Queue: The last position is connected back to the first position to make a circle. This helps in efficiently using the available space.\nPriority Queue: Elements are added with priority, and removal is based on priority rather than the order of insertion.\nDeque (Double-Ended Queue): Elements can be added or removed from both the front and rear ends."],

      "part2": ["Operations on Queues", "The fundamental operations performed on a queue include:\n\n1. Enqueue:\nAdding an element to the end (rear) of the queue.\nIf the queue is full (in the case of a fixed-size implementation), an overflow condition occurs.\n2. Dequeue:\nRemoving an element from the front (head) of the queue.\nIf the queue is empty, an underflow condition occurs.\n3. Front:\nAccessing the front element of the queue without removing it.\nUseful for peek operations.\n4. Rear:\nAccessing the last element of the queue.\nUseful for peek operations.\n5. isEmpty:\nChecking whether the queue is empty.\n6. isFull:\nChecking whether the queue is full (primarily in fixed-size implementations)."],

      "part3": ["Applications of Queues\nQueues are used in various scenarios in computer science and real-world applications. Some notable applications include:\n\n1. Operating Systems:\nProcess Scheduling: Queues manage processes in multitasking operating systems. Ready queues and waiting queues are used for scheduling tasks.\nDisk Scheduling: Managing read/write requests to a disk drive.\n2. Networking:\nBuffering: Queues buffer incoming and outgoing data packets.\nRouting: Queues are used in routers and switches to manage data packets.\n3. Simulation:\nEvent Handling: Queues handle events in simulation systems, ensuring events are processed in the order they arrive.\n4. Print Spooling:\nPrint Queues: Managing print jobs sent to a printer.\n5. Breadth-First Search (BFS):\nIn graph algorithms, BFS uses a queue to explore nodes level by level.\n6. CPU Scheduling:\nQueues manage the order of tasks to be executed by the CPU.\n7. Call Center Systems:\nManaging incoming calls in customer service operations."]
    },

    "bubblesort": {
      "part1": ["Introduction to Queues", "A queue is a linear data structure that follows the First-In-First-Out (FIFO) principle. This means that the first element added to the queue will be the first one to be removed. Queues are analogous to real-life queues, like waiting in line at a supermarket or a ticket counter.\n\nCharacteristics:\nFIFO Order: The element added first will be removed first.\nTwo Ends: Queues have two ends. The rear (or tail) is where elements are added, and the front (or head) is where elements are removed.\nDynamic Size: Queues can grow and shrink as needed, depending on the implementation.\nTypes of Queues:\nSimple Queue: Basic FIFO queue.\nCircular Queue: The last position is connected back to the first position to make a circle. This helps in efficiently using the available space.\nPriority Queue: Elements are added with priority, and removal is based on priority rather than the order of insertion.\nDeque (Double-Ended Queue): Elements can be added or removed from both the front and rear ends."],

      "part2": ["Operations on Queues", "The fundamental operations performed on a queue include:\n\n1. Enqueue:\nAdding an element to the end (rear) of the queue.\nIf the queue is full (in the case of a fixed-size implementation), an overflow condition occurs.\n2. Dequeue:\nRemoving an element from the front (head) of the queue.\nIf the queue is empty, an underflow condition occurs.\n3. Front:\nAccessing the front element of the queue without removing it.\nUseful for peek operations.\n4. Rear:\nAccessing the last element of the queue.\nUseful for peek operations.\n5. isEmpty:\nChecking whether the queue is empty.\n6. isFull:\nChecking whether the queue is full (primarily in fixed-size implementations)."],

      "part3": ["Applications of Queues\nQueues are used in various scenarios in computer science and real-world applications. Some notable applications include:\n\n1. Operating Systems:\nProcess Scheduling: Queues manage processes in multitasking operating systems. Ready queues and waiting queues are used for scheduling tasks.\nDisk Scheduling: Managing read/write requests to a disk drive.\n2. Networking:\nBuffering: Queues buffer incoming and outgoing data packets.\nRouting: Queues are used in routers and switches to manage data packets.\n3. Simulation:\nEvent Handling: Queues handle events in simulation systems, ensuring events are processed in the order they arrive.\n4. Print Spooling:\nPrint Queues: Managing print jobs sent to a printer.\n5. Breadth-First Search (BFS):\nIn graph algorithms, BFS uses a queue to explore nodes level by level.\n6. CPU Scheduling:\nQueues manage the order of tasks to be executed by the CPU.\n7. Call Center Systems:\nManaging incoming calls in customer service operations."]
    },

    "selectionsort": {
      "part1": ["Introduction to Queues", "A queue is a linear data structure that follows the First-In-First-Out (FIFO) principle. This means that the first element added to the queue will be the first one to be removed. Queues are analogous to real-life queues, like waiting in line at a supermarket or a ticket counter.\n\nCharacteristics:\nFIFO Order: The element added first will be removed first.\nTwo Ends: Queues have two ends. The rear (or tail) is where elements are added, and the front (or head) is where elements are removed.\nDynamic Size: Queues can grow and shrink as needed, depending on the implementation.\nTypes of Queues:\nSimple Queue: Basic FIFO queue.\nCircular Queue: The last position is connected back to the first position to make a circle. This helps in efficiently using the available space.\nPriority Queue: Elements are added with priority, and removal is based on priority rather than the order of insertion.\nDeque (Double-Ended Queue): Elements can be added or removed from both the front and rear ends."],

      "part2": ["Operations on Queues", "The fundamental operations performed on a queue include:\n\n1. Enqueue:\nAdding an element to the end (rear) of the queue.\nIf the queue is full (in the case of a fixed-size implementation), an overflow condition occurs.\n2. Dequeue:\nRemoving an element from the front (head) of the queue.\nIf the queue is empty, an underflow condition occurs.\n3. Front:\nAccessing the front element of the queue without removing it.\nUseful for peek operations.\n4. Rear:\nAccessing the last element of the queue.\nUseful for peek operations.\n5. isEmpty:\nChecking whether the queue is empty.\n6. isFull:\nChecking whether the queue is full (primarily in fixed-size implementations)."],

      "part3": ["Applications of Queues\nQueues are used in various scenarios in computer science and real-world applications. Some notable applications include:\n\n1. Operating Systems:\nProcess Scheduling: Queues manage processes in multitasking operating systems. Ready queues and waiting queues are used for scheduling tasks.\nDisk Scheduling: Managing read/write requests to a disk drive.\n2. Networking:\nBuffering: Queues buffer incoming and outgoing data packets.\nRouting: Queues are used in routers and switches to manage data packets.\n3. Simulation:\nEvent Handling: Queues handle events in simulation systems, ensuring events are processed in the order they arrive.\n4. Print Spooling:\nPrint Queues: Managing print jobs sent to a printer.\n5. Breadth-First Search (BFS):\nIn graph algorithms, BFS uses a queue to explore nodes level by level.\n6. CPU Scheduling:\nQueues manage the order of tasks to be executed by the CPU.\n7. Call Center Systems:\nManaging incoming calls in customer service operations."]
    }
  }
}